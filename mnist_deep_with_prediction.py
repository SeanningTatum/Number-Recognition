# -*- coding: utf-8 -*-
"""mnist-deep-with-prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/146sV9cEXVaDUS8lU4nRGazTsrWwr0927

[View in Colaboratory](https://colab.research.google.com/gist/symphco/a46aeff4296e4c1fdb6cd9e4dee0c207/mnist-deep-with-prediction.ipynb)
"""

import tensorflow as tf

from tensorflow.examples.tutorials.mnist import input_data
mnist = input_data.read_data_sets("MNIST_data/", one_hot=True)

from matplotlib import pyplot as plt
import numpy as np
def gen_image(arr):
    two_d = (np.reshape(arr, (28, 28)) * 255).astype(np.uint8)
    plt.imshow(two_d, interpolation='nearest')
    return plt

# Get a batch of two random images and show in a pop-up window.
gen_image(mnist.train.images[894]).show()
print len(mnist.train.labels)

# training
mnist.train.images
mnist.train.labels

# test
mnist.test.images
mnist.test.labels

# y = Wx + b

x = tf.placeholder(tf.float32, [None, 784], name='image')
W1 = tf.Variable(tf.truncated_normal([784, 200], stddev=0.1))
b1 = tf.Variable(tf.zeros([200]))

W2 = tf.Variable(tf.truncated_normal([200, 100], stddev=0.1))
b2 = tf.Variable(tf.zeros([100]))

W3 = tf.Variable(tf.truncated_normal([100, 60], stddev=0.1))
b3 = tf.Variable(tf.zeros([60]))

W4 = tf.Variable(tf.truncated_normal([60, 30], stddev=0.1))
b4 = tf.Variable(tf.zeros([30]))

W5 = tf.Variable(tf.truncated_normal([30, 10], stddev=0.1))
b5 = tf.Variable(tf.zeros([10]))

y1 = tf.nn.relu(tf.matmul(x, W1) + b1)
y2 = tf.nn.relu(tf.matmul(y1, W2) + b2)
y3 = tf.nn.relu(tf.matmul(y2, W3) + b3)
y4 = tf.nn.relu(tf.matmul(y3, W4) + b4)
y = tf.nn.softmax(tf.matmul(y4, W5) + b5, name='final')

actual = tf.placeholder(tf.float32, [None, 10])

# cross entropy
# loss function
lf = tf.reduce_mean(-tf.reduce_sum(
    actual * tf.log(y + 1e-5), reduction_indices=[1]
))

lr = 0.05  # learning rate
train_step = tf.train.GradientDescentOptimizer(lr).minimize(lf)

sess = tf.InteractiveSession()

tf.global_variables_initializer().run()

for step in range(10000):
  # Batching
  images, labels = mnist.train.next_batch(500)
  sess.run(train_step, feed_dict={
      x: images,
      actual: labels
  })
  
  if step % 1000 == 0:
    corrects = tf.equal(tf.argmax(y, 1), tf.argmax(actual, 1))
    accuracy = tf.reduce_mean(tf.cast(corrects, tf.float32))
    print str(sess.run(accuracy * 100.0, feed_dict={
        x: mnist.test.images,
        actual: mnist.test.labels
    })) + "%"

corrects = tf.equal(tf.argmax(y, 1), tf.argmax(actual, 1))
accuracy = tf.reduce_mean(tf.cast(corrects, tf.float32))
print str(sess.run(accuracy * 100.0, feed_dict={
    x: mnist.test.images,
    actual: mnist.test.labels
})) + "%"

def predict_what_number_this_is(a):
  i = [a]
  prediction = tf.argmax(y, 1)
  
  result = sess.run(prediction, feed_dict={x: i})
  print result

from PIL import Image, ImageFilter
import sys

def image_to_one_hot(argv):
    """
    This function returns pixel values.
    The input is a png file path.
    Pixel values should be between 1 and 0.
    """
    im = Image.open(argv).convert('L')
    width = float(im.size[0])
    height = float(im.size[1])
    newImage = Image.new('L', (28, 28), (255)) #creates white canvas of 28x28 pixels
    
    if width > height: #check which dimension is bigger
        #Width is bigger. Width becomes 20 pixels.
        nheight = int(round((20.0/width*height),0)) #resize height according to ratio width
        if (nheight == 0): #rare case but minimum is 1 pixel
            nheight = 1
        # resize and sharpen
        img = im.resize((20,nheight), Image.ANTIALIAS).filter(ImageFilter.SHARPEN)
        wtop = int(round(((28 - nheight)/2),0)) #caculate horizontal pozition
        newImage.paste(img, (4, wtop)) #paste resized image on white canvas
    else:
        #Height is bigger. Heigth becomes 20 pixels. 
        nwidth = int(round((20.0/height*width),0)) #resize width according to ratio height
        if (nwidth == 0): #rare case but minimum is 1 pixel
            nwidth = 1
         # resize and sharpen
        img = im.resize((nwidth,20), Image.ANTIALIAS).filter(ImageFilter.SHARPEN)
        wleft = int(round(((28 - nwidth)/2),0)) #caculate vertical pozition
        newImage.paste(img, (wleft, 4)) #paste resized image on white canvas
    
    #newImage.save("sample.png")

    tv = list(newImage.getdata()) #get pixel values
    
    #normalize pixels to 0 and 1. 0 is pure white, 1 is pure black.
    tva = [ (255-x)*1.0/255.0 for x in tv] 
    return tva

from google.colab import files

uploaded = files.upload()

a = image_to_one_hot('Screen Shot 2018-08-18 at 4.32.11 PM.png')
gen_image(a).show()
predict_what_number_this_is(a)

saver = tf.train.Saver()
save_path = saver.save(sess, "data/my_model2.ckpt")
print "Model saved in file: {}".format(save_path)

import os
print os.getcwd()
print os.listdir('data')

from google.colab import files
files.download('data/my_model2.ckpt.meta')